type GlobalStats @entity {
  # Singleton entity with ID "global"
  id: ID!
  # Total NFTs currently staked across all contracts
  totalStaked: BigInt!
  # Total NFTs burned across all contracts
  totalBurned: BigInt!
  # Total staking rewards claimed across all contracts (excludes burn rewards)
  totalStakingRewardsClaimed: BigDecimal!
  # Total burn bonus rewards claimed across all contracts (excludes staking rewards)
  totalBurnRewardsClaimed: BigDecimal!
  # Total of ALL rewards claimed (staking + burn bonus combined)
  totalAllRewardsClaimed: BigDecimal!
}

type StakingContract @entity {
  # Staking contract address
  id: ID!
  # NFT contract being staked
  nft: Bytes!
  # Rewards token address
  rewardsToken: Bytes!
  # Current reward rate per second
  rewardRatePerSecond: BigInt!
  # Current burn bonus in basis points
  burnBonusBps: BigInt!
  # Total NFTs currently staked
  totalStaked: BigInt!
  # Total NFTs burned
  totalBurned: BigInt!
  # Total staking rewards claimed (excludes burn rewards)
  totalStakingRewardsClaimed: BigDecimal!
  # Total burn bonus rewards claimed (excludes staking rewards)
  totalBurnRewardsClaimed: BigDecimal!
  # Number of parameter epochs
  epochCount: BigInt!
  # All stakes
  stakes: [Stake!]! @derivedFrom(field: "contract")
  # All parameter epochs
  parameterEpochs: [ParameterEpoch!]! @derivedFrom(field: "contract")
}

type ParameterEpoch @entity {
  # contract address + epoch index
  id: ID!
  # staking contract
  contract: StakingContract!
  # epoch start timestamp
  startTime: BigInt!
  # reward rate for this epoch
  rewardRatePerSecond: BigInt!
  # burn bonus for this epoch
  burnBonusBps: BigInt!
  # epoch index
  epochIndex: BigInt!
}

type Stake @entity {
  # contract address + token id
  id: ID!
  # staking contract
  contract: StakingContract!
  # token ID
  tokenId: BigInt!
  # owner/staker (User entity)
  owner: User!
  # owner address (for convenience)
  ownerAddress: Bytes!
  # payout recipient address (if set, otherwise defaults to owner)
  payoutRecipient: Bytes
  # staked timestamp
  stakedAt: BigInt!
  # last claim timestamp for normal staking
  lastClaimAt: BigInt!
  # whether NFT is burned
  burned: Boolean!
  # burned timestamp
  burnedAt: BigInt
  # last burn reward claim timestamp
  lastBurnClaimAt: BigInt
  # total staking rewards claimed (excludes burn rewards)
  totalStakingRewardsClaimed: BigDecimal!
  # total burn bonus rewards claimed (excludes staking rewards)
  totalBurnRewardsClaimed: BigDecimal!
  # current status: STAKED, BURNED, UNSTAKED
  status: StakeStatus!
  # all stake events
  events: [StakeEvent!]! @derivedFrom(field: "stake")
  # all reward claims
  claims: [RewardClaim!]! @derivedFrom(field: "stake")
}

enum StakeStatus {
  STAKED
  BURNED
  UNSTAKED
}

type StakeEvent @entity {
  # transaction hash + log index
  id: ID!
  # stake
  stake: Stake!
  # event type
  type: StakeEventType!
  # user (User entity)
  user: User!
  # user address (for convenience)
  userAddress: Bytes!
  # token ID
  tokenId: BigInt!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

enum StakeEventType {
  STAKE
  UNSTAKE
  BURN
}

type RewardClaim @entity {
  # transaction hash + log index
  id: ID!
  # stake
  stake: Stake!
  # user (User entity)
  user: User!
  # user address (for convenience)
  userAddress: Bytes!
  # token ID
  tokenId: BigInt!
  # amount claimed
  amount: BigDecimal!
  # is burn reward
  isBurnReward: Boolean!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

type BatchOperation @entity {
  # transaction hash + log index
  id: ID!
  # operation type: BATCH_STAKE, BATCH_UNSTAKE, BATCH_BURN, BATCH_CLAIM
  type: BatchOperationType!
  # user who initiated the batch operation
  user: User!
  # user address (for convenience)
  userAddress: Bytes!
  # token IDs involved in the batch operation
  tokenIds: [BigInt!]!
  # recipient address (for batch stake/burn operations)
  recipient: Bytes
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

enum BatchOperationType {
  BATCH_STAKE
  BATCH_UNSTAKE
  BATCH_BURN
  BATCH_CLAIM
}

type PayoutRecipientUpdate @entity {
  # transaction hash + log index
  id: ID!
  # stake
  stake: Stake!
  # token ID
  tokenId: BigInt!
  # owner address
  owner: Bytes!
  # recipient address
  recipient: Bytes!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

type User @entity {
  # user address
  id: ID!
  # total NFTs currently staked
  totalStaked: BigInt!
  # total NFTs burned
  totalBurned: BigInt!
  # total staking rewards claimed (excludes burn rewards)
  totalStakingRewardsClaimed: BigDecimal!
  # total burn bonus rewards claimed (excludes staking rewards)
  totalBurnRewardsClaimed: BigDecimal!
  # all user stakes
  stakes: [Stake!]! @derivedFrom(field: "owner")
  # all stake events
  stakeEvents: [StakeEvent!]! @derivedFrom(field: "user")
  # all reward claims
  claims: [RewardClaim!]! @derivedFrom(field: "user")
}

type DailyStat @entity {
  # contract address + day id (timestamp / 86400)
  id: ID!
  # day id
  dayId: BigInt!
  # date timestamp (start of day)
  date: BigInt!
  # staking contract
  contract: Bytes!
  # total staked at end of day
  totalStaked: BigInt!
  # total burned at end of day
  totalBurned: BigInt!
  # new stakes on this day
  newStakes: BigInt!
  # new unstakes on this day
  newUnstakes: BigInt!
  # new burns on this day
  newBurns: BigInt!
  # total rewards claimed on this day
  rewardsClaimed: BigDecimal!
  # total burn rewards claimed on this day
  burnRewardsClaimed: BigDecimal!
}
