type StakingContract @entity {
  # Staking contract address
  id: ID!
  # NFT contract being staked
  nft: Bytes!
  # Rewards token address
  rewardsToken: Bytes!
  # Current reward rate per second
  rewardRatePerSecond: BigInt!
  # Current burn bonus in basis points
  burnBonusBps: BigInt!
  # Total NFTs currently staked
  totalStaked: BigInt!
  # Total NFTs burned
  totalBurned: BigInt!
  # Total rewards claimed
  totalRewardsClaimed: BigDecimal!
  # Total burn rewards claimed
  totalBurnRewardsClaimed: BigDecimal!
  # Number of parameter epochs
  epochCount: BigInt!
  # All stakes
  stakes: [Stake!]! @derivedFrom(field: "contract")
  # All parameter epochs
  parameterEpochs: [ParameterEpoch!]! @derivedFrom(field: "contract")
}

type ParameterEpoch @entity {
  # contract address + epoch index
  id: ID!
  # staking contract
  contract: StakingContract!
  # epoch start timestamp
  startTime: BigInt!
  # reward rate for this epoch
  rewardRatePerSecond: BigInt!
  # burn bonus for this epoch
  burnBonusBps: BigInt!
  # epoch index
  epochIndex: BigInt!
}

type Stake @entity {
  # contract address + token id
  id: ID!
  # staking contract
  contract: StakingContract!
  # token ID
  tokenId: BigInt!
  # owner/staker (User entity)
  owner: User!
  # owner address (for convenience)
  ownerAddress: Bytes!
  # staked timestamp
  stakedAt: BigInt!
  # last claim timestamp for normal staking
  lastClaimAt: BigInt!
  # whether NFT is burned
  burned: Boolean!
  # burned timestamp
  burnedAt: BigInt
  # last burn reward claim timestamp
  lastBurnClaimAt: BigInt
  # total rewards claimed (normal staking)
  totalRewardsClaimed: BigDecimal!
  # total burn rewards claimed
  totalBurnRewardsClaimed: BigDecimal!
  # current status: STAKED, BURNED, UNSTAKED
  status: StakeStatus!
  # all stake events
  events: [StakeEvent!]! @derivedFrom(field: "stake")
  # all reward claims
  claims: [RewardClaim!]! @derivedFrom(field: "stake")
}

enum StakeStatus {
  STAKED
  BURNED
  UNSTAKED
}

type StakeEvent @entity {
  # transaction hash + log index
  id: ID!
  # stake
  stake: Stake!
  # event type
  type: StakeEventType!
  # user (User entity)
  user: User!
  # user address (for convenience)
  userAddress: Bytes!
  # token ID
  tokenId: BigInt!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

enum StakeEventType {
  STAKE
  UNSTAKE
  BURN
}

type RewardClaim @entity {
  # transaction hash + log index
  id: ID!
  # stake
  stake: Stake!
  # user (User entity)
  user: User!
  # user address (for convenience)
  userAddress: Bytes!
  # token ID
  tokenId: BigInt!
  # amount claimed
  amount: BigDecimal!
  # is burn reward
  isBurnReward: Boolean!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

type User @entity {
  # user address
  id: ID!
  # total NFTs currently staked
  totalStaked: BigInt!
  # total NFTs burned
  totalBurned: BigInt!
  # total rewards claimed
  totalRewardsClaimed: BigDecimal!
  # total burn rewards claimed
  totalBurnRewardsClaimed: BigDecimal!
  # total NFTs owned (not staked or burned)
  totalOwned: BigInt!
  # all user stakes
  stakes: [Stake!]! @derivedFrom(field: "owner")
  # all stake events
  stakeEvents: [StakeEvent!]! @derivedFrom(field: "user")
  # all reward claims
  claims: [RewardClaim!]! @derivedFrom(field: "user")
  # all NFTs owned by this user
  nfts: [NFT!]! @derivedFrom(field: "owner")
}

type NFT @entity {
  # NFT contract address + token ID
  id: ID!
  # NFT contract address
  contract: Bytes!
  # token ID
  tokenId: BigInt!
  # current owner (User entity)
  owner: User!
  # current owner address (for convenience)
  ownerAddress: Bytes!
  # whether NFT is currently staked
  isStaked: Boolean!
  # whether NFT has been burned
  isBurned: Boolean!
  # all transfer events for this NFT
  transfers: [NFTTransfer!]! @derivedFrom(field: "nft")
}

type NFTTransfer @entity {
  # transaction hash + log index
  id: ID!
  # NFT
  nft: NFT!
  # NFT contract address
  contract: Bytes!
  # token ID
  tokenId: BigInt!
  # from address
  from: Bytes!
  # to address
  to: Bytes!
  # transaction hash
  transactionHash: Bytes!
  # timestamp
  timestamp: BigInt!
  # block number
  blockNumber: BigInt!
  # log index
  logIndex: BigInt!
}

type DailyStat @entity {
  # contract address + day id (timestamp / 86400)
  id: ID!
  # day id
  dayId: BigInt!
  # date timestamp (start of day)
  date: BigInt!
  # staking contract
  contract: Bytes!
  # total staked at end of day
  totalStaked: BigInt!
  # total burned at end of day
  totalBurned: BigInt!
  # new stakes on this day
  newStakes: BigInt!
  # new unstakes on this day
  newUnstakes: BigInt!
  # new burns on this day
  newBurns: BigInt!
  # total rewards claimed on this day
  rewardsClaimed: BigDecimal!
  # total burn rewards claimed on this day
  burnRewardsClaimed: BigDecimal!
}
